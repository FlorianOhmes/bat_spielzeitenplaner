
Im Großen und Ganzen ist zu konstatieren, dass das Projekt \texttt{Spielzeitenplaner} 
gezeigt hat, wie eine Anwendung ganzheitlich und auf verschiedenen Ebenen testgetrieben 
entwickelt werden kann. \\ 
Für die einzelnen \texttt{WebPages}, deren testgetriebene Entwicklung zu Beginn im 
Vordergrund stand, ist ein Konzept entwickelt worden, nach dem jede einzelne Seite 
strukturiert getestet wird: Zunächst wird durch eine Reihe von Tests gewährleistet, dass 
\texttt{Essentials} wie Navigationsleiste und Footer oder aber auch die korrekte 
Überschrift einer Seite vorhanden sind und den gewünschten Anforderungen entsprechen. 
Dabei wird für Footer und Navigationsleiste in jeder Testklasse jeweils getestet, ob 
diese auf der entsprechenden Seite vorhanden sind, wohingegen eine detaillierte Testung 
der ordnungsgemäßen Funktionsweise in eine eigens dafür eingerichtete Klasse ausgelagert 
ist. Die so entstandenen \texttt{Fragmente} können nach ihrer Entwicklung dann mithilfe 
von \texttt{Thymeleaf} in die jeweilige Seite eingefügt werden, dies erspart den 
Entwickelnden ein detailliertes Testing der \texttt{Essentials} auf jeder 
\texttt{WebPage}. \\ 
Im Anschluss erfolgt eine Testung der einzelnen Bereiche einer Seite, beispielsweise ob 
der Bereich \texttt{Spieler-Daten} auf der Spieler-Seite korrekt strukturiert ist. 
Dies beinhaltet unter anderem auch Tests, die die Anwesenheit von Formularen erzwingen, 
die in diesem Projekt zum einen der Anzeige bereits gespeicherter Daten dienen, den 
Nutzenden zum anderen aber auch die Möglichkeit bieten, Anfragen zum Speichern oder 
Bearbeiten an den Server zu senden. Darüber hinaus ist mithilfe geeigneter Tests 
ebenfalls sichergestellt worden, dass Daten, wie Spielerinformationen, Teamname oder 
Formation, die im Model bereitstehen, wie gewünscht in die entsprechende Seite 
hineingerendert werden. \\ 
Für das Testing der einzelnen \texttt{WebPages} erwies sich \texttt{Jsoup} als nützliches Werkzeug zum Parsen und Extrahieren von HTML-Elementen aus einer Seite. Über die 
Komplexität der \texttt{CSS-Query} konnte dabei gezielt gesteuert werden, wie 
detailliert die jeweilige Seite im Hinblick auf ihre Struktur getestet werden soll. \\ 
Im Bereich des Controller-Testing ist gezeigt worden, wie die Web-Steuereinheiten mit 
ihren verschiedenen Aufgaben testgetrieben entwickelt und überprüft werden können. Dabei 
ist grundsätzlich zwischen GET- und POST-Requests unterschieden worden. Bei Ersteren 
wird zunächst mithilfe eines geeigneten Tests das grundlegende Routing überprüft und 
etabliert sowie sichergestellt, dass das richtige HTML-Template zurückgegeben wird. 
In einem zweiten Schritt kann dann überprüft werden, ob die geforderten Daten durch den 
Controller bei der Service-Schicht angefragt werden und das entsprechende Model geladen 
werden. \\ 
Die grundsätzliche Vorgehensweise bei POST-Requests unterschiedet sich ein wenig von der, 
die bei GET-Requests angewendet wird. In einem solchen Fall wird zwar auch zunächst erst 
das grundlegende Routing überprüft und eingerichtet, in einem weiteren Schritt jedoch 
überprüft, ob die richtige Methode des für die Anfrage zuständigen Services aufgerufen 
wird. Schließlich müssen die übermittelten Daten beim Abschicken eines Formulars noch 
durch den Controller validiert werden. Um diese Funktionalität umzusetzen, sind für 
jeden Fall gezielte Anfragen konstruiert worden, die eine korrekte Validierung 
überprüfen sollen. Dabei wurde nicht nur getestet, ob die Fehler im Model ordnungsgemäß 
an das entsprechende Objekt gebunden worden sind, sondern auch, ob die Fehlermeldungen 
den Nutzenden auf der Seite korrekt angezeigt werden. \\ 
Durch die Entwicklung der Web-Schicht und das Anwenden der Onion-Architektur ist 
gleichzeitig aber auch die Existenz der einzelnen Services erzwungen worden. Im Rahmen 
der Service-Tests sind grundlegende Operationen zur Delegation von Benutzeranfragen 
getestet worden, beispielsweise die \texttt{loadPlayers}-Methode des 
\texttt{PlayerService}, die der Web-Schicht alle gespeicherten Spieler zur Verfügung 
stellt, oder die \texttt{submitAssessments}-Methode des \texttt{RecapService}, die 
die vom Trainerteam vorgenommenen Bewertungen zur Speicherung an das zuständige 
Repository weiterleitet. \\ 
Dabei ist es für eine ordnungsgemäße Funktionsweise der Anwendung unerlässlich, dass 
Benutzeranfragen mit ihren Daten korrekt weitergeleitet werden, daher wurde hier nicht 
nur getestet, ob die das Repository und die richtige Methode aufgerufen wird, sondern 
auch, ob Parameter wie erwartet übergeben werden. Während die Überprüfung der 
Parameterübergabe insbesondere bei zu speichernden Daten essenziell ist, muss bei 
Methoden, die Daten aus der Datenbank laden und diese bereitstellen insbesondere der 
Rückgabewert der Methode unter die Lupe genommen werden. \\ 
Des Weiteren ist noch das Testing der \texttt{calculateScore}-Methode des 
\texttt{PlayerService} vorgestellt worden, für das zunächst einige 
\texttt{Arrange}-Schritte notwendig sind. Doch auch hier konnte gezeigt werden, wie 
durch gezieltes Mocking sämtliche Abhängigkeiten zu den die Service-Schicht umgebenen 
Komponenten aufgelöst und diese unter Kontrolle gebracht werden können. Dies ermöglichte 
in der Folge ein gezieltes Testing verschiedener Situationen, also zum Beispiel ob die 
\texttt{calculateScore}-Methode den Score für ein bestimmtes Kriterium korrekt berechnet 
und ob dies auch für die Trainingsbeteiligung erwartungsgemäß funktioniert. \\ 
Schließlich ist noch das Testing der Persistenz-Schicht veranschaulicht worden. Bevor 
mit der eigentlichen testgetriebenen Entwicklung begonnen werden konnte, musste die 
Testklasse jedoch zunächst erst eingerichtet werden. Dazu gehört das Verwenden der 
benötigten \texttt{Testcontainers-} und Spring-Annotationen, aber auch das Definieren 
und Konfigurieren eines \texttt{postgreSQLContainers}. Im Anschluss muss noch 
sichergestellt werden, dass Spring die Produktiv-Datenbank für die Dauer der Tests 
durch die Test-Datenbank ersetzt. \\ 
Das eigentliche Schreiben der Tests geschah dann wie folgt: Als erstes ist stets getestet 
worden, dass das Laden und Speichern einer Entität in der Datenbank korrekt implementiert 
ist. Um dies zu erreichen, sind die entsprechenden Methodensignaturen in den 
Repository-Interfaces eingefügt und in der jeweiligen Implementierung dann konkret 
entwickelt worden. \\ 
Neben den Standardmethoden -- \texttt{save}, \texttt{findById} oder \texttt{findAll} -- 
sind darüber hinaus noch spezifischere Methode mithilfe von 
\texttt{JDBCs Derived Queries} realisiert worden. Eine davon ist eine Methode des 
\texttt{AssessmentRepository}, die Bewertungen nach Spieler, Kriterium und Datum 
filtert. Auch diese ist durch geeignetes Testing entwickelt worden, um sicherzustellen, 
dass die Methode den gewünschten Anforderungen entspricht. \\ 
Abschließend ist festzuhalten, dass das Projekt \texttt{Spielzeitenplaner} nicht nur 
gezeigt hat, wie eine Anwendung von Beginn bis Ende testgetrieben entwickelt werden kann, 
sondern auch eine Lösung für bekannte Probleme im Jugendfußball sein kann. Indem  
Kriterien erstellt und Spieler nach Trainings anhand dieser bewertet werden, wird eine 
systematische Reflexion im Trainerteam angeregt. Die Berechnung von Scores -- basierend 
auf den Bewertungen -- führt dazu, dass Spielzeiten für jeden einzelnen Spieler geplant 
und so eine möglichst faire Aufteilung gewährleistet wird. Diese systematische 
Spielzeitenplanung -- kombiniert mit einer transparenten Kommunikation -- kann 
möglichen Diskussionen mit Spielern und Eltern vorbeugen und dem Spieler transparent 
aufzeigen, wie er sich verbessern bzw. was er tun kann, um auf mehr Spielzeit zu 
kommen. \\ 
Die Anwendung in seiner gegenwärtigen Form stellt eine Art Grundversion mit den 
wichtigsten Features dar. Sie kann in den kommenden Jahren weiter ausgebaut und um 
einige nützliche Features erweitert werden. Diese beinhalten die Möglichkeit, mehrere 
Teams zu erstellen, falls Fußballehrende Teil von mehr als nur einem Team sind, die 
dauerhafte Speicherung der tatsächlichen Spielzeiten über eine Saison hinweg, sodass 
nicht nur von Spiel zu Spiel geplant, sondern die Spielzeit auch über eine ganze Saison 
hinweg betrachtet werden kann oder aber eine \texttt{Drag and Drop}-Funktionalität 
bei der Anpassung der Startelf, um diesen Schritt für den Benutzer intuitiver zu 
gestalten. 

