
Nachdem nun ausgiebig über das Testing des Web-Interfaces gesprochen wurde, soll 
sich das kommende Kapitel nun einer weiteren wichtigen Komponente, der 
Service-Schicht, widmen. Diese kann unabhängig von den anderen Komponenten entwickelt 
werden. Im Falle des hier vorliegenden Projektes -- der Entwicklung des 
Spielzeitenplaners -- ist die Service-Schicht schrittweise aufgebaut worden. \\ 
Dabei wurde sich an verschiedenen \texttt{use cases} orientiert, die die 
funktionalen Anforderungen der Anwendung hervorheben und die wiederum eine 
Interaktion der Nutzenden mit der Web-Oberfläche als Startpunkt besitzen. Ein 
Beispiel für einen in diesem Projekt vorliegenden \texttt{use case} wäre 
beispielsweise das Löschen eines Spielers durch die Nutzenden. Durch einen Klick 
auf den \texttt{Löschen}-Button auf der \texttt{TeamPage} wird das entsprechende 
Formular an den Server geschickt. Dort wird es von einer entsprechend 
konfigurierten Handler-Methode eines Controllers in Empfang genommen und 
verarbeitet. Im Zuge dessen wird die entsprechende Service-Methode -- in diesem 
Fall die \texttt{deletePlayer}-Methode des \texttt{PlayerService} -- aufgerufen, 
die den Fall dann bearbeitet. Schließlich ruft diese dann eine entsprechende 
Repository-Methode auf, die wiederum für die Löschung der Spieler-Daten in der 
Datenbank zuständig ist. \\ 
Innerhalb dieser Aufruf-Kette fordert also gewissermaßen eine Komponente die 
Existenz einer anderen. Bezogen auf die Onion-Architektur bedeutet dies: die äußere 
Web-Schicht erwartet das Vorhandensein der inneren Schichten -- also der 
Service-Schicht und des Domain-Models -- und diese wiederum die Verfügbarkeit der 
(äußeren) Persistenz-Schicht. Auf diese Weise können sich Entwickelnde vom einen 
Ende der Software-Zwiebel hindurch zum anderen arbeiten. \\ 
Ein konkretes Beispiel aus der Entwicklung des Spielzeitenplaners ist dem Commit 
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/commit/0a64ca3359402c06358b43cc41236ca24c2ec9cd#diff-c21f1f59588419db3d2efda09d4e20682f83653b4ef81ca9847d7458bc5b2f5f}{\texttt{0a64ca3}}
zu entnehmen. Durch die Implementierung der Funktionalitäten in der Web-Schicht -- 
siehe dazu die Änderungen an der \texttt{TeamControllerTest.java} -- wird unter 
anderem das Vorhandensein der \texttt{deletePlayer}-Methode und damit verbunden auch 
die Existenz des \texttt{PlayerService} an sich gefordert. Um den Test also bestehen 
zu lassen und schließlich committen zu können ist die Erstellung einer 
\texttt{PlayerService.java} und einer darin enthaltenen \texttt{deletePlayer}-Methode 
zwingend erforderlich. \\ 
Sobald die Service-Klasse vorhanden ist, kann sie auch testgetrieben entwickelt 
werden. Im Folgenden soll nun zunächst das Vorgehen bei den sogenannten 
Basisoperationen geschildert werden, ehe dann auf komplexere Testfälle eingegangen 
werden soll. Das zuvor genannte Beispiel für die \texttt{deletePlayer}-Methode lässt 
sich einfach und unkompliziert wie folgt testgetrieben entwickeln: 

\begin{quote}
\begin{verbatim}
@Test
...
void test_01() {
    Integer playerId = 17;
    playerService.deletePlayer(playerId);
    verify(playerRepository).deleteById(playerId);
}
\end{verbatim}
\end{quote}

Hier wird also überprüft, ob der \texttt{PlayerService} die Löschanfrage korrekt 
weiterverarbeitet. In diesem Fall bedeutet dies, dass diese an das zuständige 
Repository delegiert wird. Dabei ist besonders wichtig, dass das richtige Repository 
-- hier also das \texttt{PlayerRepository} -- verwendet wird und die entsprechende 
Methode mit dem aus der ursprünglichen Anfrage gesendeten Objekt aufgerufen wird. \\ 
Um diesen Test so schreiben zu können, muss das \texttt{PlayerRepository} zunächst 
mithilfe von \texttt{Mockito} gemockt werden, um die Kontrolle über sämtliche 
Aktionen des Repository zu erhalten, und der \texttt{PlayerService} mit dem soeben 
gemockten Repository ordnungsgemäß initialisiert werden, was wiederum einen 
geeigneten Konstruktor in der \texttt{PlayerService.java} voraussetzt. In diesem Zuge 
wird dann auch das Interface 
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/e4bc878ddf49753d522e2363f3b258093bab1d2f/spielzeitenplaner/src/main/java/de/bathesis/spielzeitenplaner/services/PlayerRepository.java}{\texttt{PlayerRepository.java}}
innerhalb der Service-Schicht etabliert und seine Implementierung, die mit 
\texttt{@Repository} annotierte 
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/e4bc878ddf49753d522e2363f3b258093bab1d2f/spielzeitenplaner/src/main/java/de/bathesis/spielzeitenplaner/database/PlayerRepositoryImpl.java}{\texttt{PlayerRepositoryImpl.java}}, 
in der Persistenzschicht. Ihre testgetriebene Entwicklung ist in Kapitel 3.5 
beschrieben. Sind die zuvor genannten Voraussetzungen implementiert, so kann der 
\texttt{deletePlayer}-Methode der Aufruf \texttt{playerRepository.deleteById(id)} 
hinzugefügt werden, wobei \texttt{id} als Argument entgegen genommen wird (siehe dazu 
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/e4bc878ddf49753d522e2363f3b258093bab1d2f/spielzeitenplaner/src/main/java/de/bathesis/spielzeitenplaner/services/PlayerService.java}{\texttt{PlayerService.java nach Commit e4bc878}}). \\ 
Die Methode zum Löschen eines Spielers ist ein Beispiel für eine Basisoperation, bei 
der eine Anfrage an die entsprechende Repository-Methode weitergeleitet wird. Hier 
steht also die Delegation der Aufgabe im Vordergrund, während das Repository sich 
um die Löschlogik kümmert. Für die Verifizierung der Übergabe des korrekten 
Parameters wurde \texttt{deleteById(playerId)} auf \texttt{verify(playerRepository)} 
aufgerufen. Dies ist in diesem Fall auch völlig ausreichend, sollten jedoch mehrere 
Methodenaufrufe mit unterschiedlichen Argumenten auftreten, komplexe Objekte -- wie 
beispielsweise ein Spieler mit seinen verschieden Attributen -- übergeben oder aber 
Eigenschaften innerhalb des Methodenaufrufs verändert werden, so ist der Gebrauch 
eines \texttt{ArgumentCaptors} durchaus sinnvoll, wie \texttt{test\_01} der 
\texttt{RecapServiceTest.java} veranschaulicht: 


\pagebreak


\begin{quote}
\begin{verbatim}
@Test
@DisplayName("Die Bewertungen werden gespeichert.")
void test_01() {
    List<Assessment> assessments = new ArrayList<>(List.of(
            // Hier manuell erstellte Bewertungen hinzufügen 
    ));
    ArgumentCaptor<Assessment> assessmentCaptor = 
        ArgumentCaptor.forClass(Assessment.class);

    recapService.submitAssessments(assessments);

    verify(assessmentRepository, times(4))
        .save(assessmentCaptor.capture());

    List<Assessment> savedAssessments = 
        assessmentCaptor.getAllValues();

    assertThat(savedAssessments).isEqualTo(assessments);
}
\end{verbatim}
\end{quote}

In dem oben gezeigten Test wird der \texttt{ArgumentCaptor} dazu benutzt, die 
verschiedenen Bewertungen, mit der die \texttt{save}-Methode aufgerufen wird, 
einzufangen. Bevor dies mithilfe \texttt{assessmentCaptor.capture()} geschehen kann, 
muss die spezifische Klasse, für die der \texttt{Captor} programmiert ist, zunächst 
bei der Initialisierung des \texttt{assessmentCaptors} konfiguriert werden. Nach dem 
Erfassungsvorgang können alle gespeicherten \texttt{Assessments} dann abgerufen und 
in einer Liste gespeichert, um schließlich weiteren Überprüfungen mithilfe von 
\texttt{assertThat} unterzogen werden zu können. \\ 
Während bisher Gesagtes vor allen Dingen das Delegieren eines Aufrufs an die 
Persistenzschicht und die Überprüfung der Übergabe von Parametern in den Vordergrund 
stellt, soll nun im Folgenden auf die Überprüfung von Rückgabewerten eingegangen 
werden. Eine in diesem Projekt häufig getestete Methode ist die 
\texttt{load}-Methode, die Daten aus der Datenbank anfragt und diese dem Web-UI zur 
Verfügung stellt. Beispielsweise liefert die \texttt{loadCriteria}-Methode des 
\texttt{SettingsService} die aktuell gespeicherten Kriterien, \texttt{loadFormation} 
stellt die aktuell genutzte Formation bereit und \texttt{loadPlayers} gewährleistet 
die Versorgung der Webschicht mit den aktuellen Spielern im Team. Letztere wird wie folgt getestet: 

\begin{quote}
\begin{verbatim}
@Test
...
void test_02() {
    List<Player> players = TestObjectGenerator.generatePlayers();
    when(playerRepository.findAll()).thenReturn(players);

    List<Player> loadedPlayers = playerService.loadPlayers();

    verify(playerRepository).findAll();
    assertThat(loadedPlayers)
        .containsExactlyInAnyOrderElementsOf(players);
}
\end{verbatim}
\end{quote}

Nachdem der \texttt{TestObjectGenerator} eine Liste von (Test-)Spielern 
bereitgestellt hat, kann das \texttt{PlayerRepository} so konfiguriert werden, dass 
es diese Liste von Spielern zurückgibt. Sämtliche Repositories werden für die 
Service-Tests gemockt, um die Service-Schicht von der Datenbank losgelöst testen zu 
können. In dem folgenden \texttt{Act}-Schritt des Tests wird die 
\texttt{loadPlayers}-Methode dann ausgeführt und die Rückgabe in einer lokalen 
Variable gespeichert. So kann dann abschließend getestet werden, ob die 
\texttt{findAll}-Methode des \texttt{PlayerRepository} aufgerufen wurde -- die 
Überprüfung der Delegation eines Requests ist ja bereits aus den vorangegangenen 
Tests bekannt -- und ob die geladenen Spieler auch wirklich der gewünschten Liste 
entsprechen. \\ 
Dabei wird die 
\texttt{containsExactlyInAnyOrderElementsOf}-Methode verwendet, um 
sicherzustellen, dass sich auch wirklich nur die erwarteten Spieler in der Liste 
befinden und keine weiteren. Außerdem spielt die Reihenfolge keine Rolle, damit der 
Test auch weiterhin besteht, sollten die Spieler nach Namen, Score, Trikotnummer oder 
Position geordnet werden. 
Zusammenfassend kann gesagt werden, dass beim Delegieren und Koordinieren von 
Anfragen ein besonderes Augenmerk zum einen auf den korrekten Methodenaufruf, zum 
anderen aber auch die Überprüfung der Übergabe der korrekten Parameter sowie 
die Richtigkeit des Rückgabewertes gelegt werden sollte, denn diese sind für eine 
ordnungsgemäße Funktionsweise der Anwendung unerlässlich. \\ 
Darüber hinaus ist es wichtig Methoden der Service-Schicht zu testen, die sich nicht 
eindeutig einer Klasse aus dem Domain-Model zuordnen lassen oder aber eine 
Verknüpfung zwischen mehreren Entitäten herstellen. Im Bezug auf den 
Spielzeitenplaner ist dies zum Beispiel der Fall in der
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/main/spielzeitenplaner/src/main/java/de/bathesis/spielzeitenplaner/services/SpielzeitenService.java}{\texttt{SpielzeitenService.java}}, 
in der aus allen verfügbaren Spielern ein Kader oder aus dem Kader wiederum eine 
Startelf ermittelt werden soll, und in der 
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/main/spielzeitenplaner/src/main/java/de/bathesis/spielzeitenplaner/services/PlayerService.java}{\texttt{PlayerService.java}}, in der für einen Spieler 
für jedes Kriterium anhand mehrerer Bewertungen ein Score berechnet wird. \\ 
Mit Letzterem ist die \texttt{calculateScore}-Methode gemeint, die mithilfe mehrerer 
Tests in ihre gegenwärtige Form gebracht worden ist. Der Kern der Methode besteht 
aus einer \texttt{if}-Abfrage, die, wenn es sich um das Kriterium 
\texttt{Trainingsbeteiligung} handelt, eine private Methode speziell für diesen 
Fall aufruft, für alle anderen Kriterien den Score mithilfe der 
\texttt{calculateScoreOther}-Methode auf die gewöhnliche Weise berechnet. Die 
einzelnen Abzweigungen der Methode lassen sich gut in getrennten Tests entwickeln. 
Im Folgenden ist der Test gegeben, der überprüft, ob die Score-Berechnung im Falle 
eines gewöhnlichen Kriteriums -- also einem anderen als der 
\texttt{Trainingsbeteiligung} -- erfolgreich funktioniert: 


\pagebreak


\begin{quote}
\begin{verbatim}
@Test
...
void test_06() {
    Integer playerId = 1;
    Criterion criterion = 
        new Criterion(2, "Sozialverhalten", "S", 0.25);
    Setting weeksGeneral = new Setting(1195, "weeksGeneral", 4.0);
    List<Assessment> assessments = new ArrayList<>(List.of(
        // Erstellen mehrerer Assessments (Bewertungen) 
        ... 
    ));
    Double expectedScore = assessments.stream()
        .mapToDouble(Assessment::getValue).average().orElseThrow();

    when(criterionRepository.findById(criterion.getId()))
        .thenReturn(Optional.of(criterion));
    when(settingRepository.findById(weeksGeneral.getId()))
        .thenReturn(Optional.of(weeksGeneral));
    when(assessmentRepository.findByPlayerIdAndCriterionIdAndDateAfter(
            playerId, criterion.getId(), LocalDate.now().minusWeeks(
                weeksGeneral.getValue().intValue()).minusDays(1))
        ).thenReturn(assessments);

    Double score = 
        playerService.calculateScore(criterion.getId(), playerId);

    assertThat(score).isEqualTo(expectedScore);
}
\end{verbatim}
\end{quote}

Zunächst einmal sind hier einige \texttt{Arrange}-Schritte notwendig: Da die Methode 
eine \texttt{playerId} und eine \texttt{criterionId} als Eingabeparameter bekommt, 
müssen diese erst einmal definiert werden. Außerdem ist bei der Score-Berechnung 
der Wert der Einstellung \texttt{weeksGeneral} vonnöten, da dieser den Zeitraum 
festlegt, innerhalb dessen Bewertungen berücksichtigt werden. Des Weiteren wird dann 
noch eine Liste mit verschiedenen Bewertungen erstellt, die in die Berechnung 
einfließen sollen. Schließlich ergibt sich der \texttt{expectedScore}, der den 
Durchschnitt der Werte aller gültigen Bewertungen des Spielers für ein bestimmtes 
Kriterium bildet. \\ 
Nachdem die nötigen Werte und (Test-)Objekte generiert worden sind, müssen nun 
die durch die \texttt{calculateScore}-Methode direkt oder indirekt genutzten 
Repositories und ihre Methoden gemockt werden, um so die Kontrolle über die durch 
die Persistenzschicht bereitgestellten Daten zu bekommen, denn nur so kann es zu 
einer Überprüfung der Funktionsweise der zu testenden Service-Methode kommen. 
So müssen zum Beispiel die \texttt{findById}-Methoden des 
\texttt{criterionRepository} und des \texttt{settingRepository} so konfiguriert 
werden, dass sie bei einem Aufruf die zuvor generierten Objekte -- also 
\texttt{criterion} bzw. \texttt{weeksGeneral} -- zurückgeben. \\ 
Darüber hinaus muss dann noch diejenige Methode des \texttt{assessmentRepository}, 
die die Bewertungen nach Spieler, Kriterium und Datum filtert und die entsprechenden 
Daten lädt, so justiert werden, dass sie die zuvor erstellten Test-Bewertungen 
zur Verfügung stellt. Das eigentliche Testing des Ladens von Bewertungen aus der 
Datenbank ist in Kapitel 3.5 beschrieben, diese Funktionalität wird losgelöst von den 
anderen Schichten getestet, denn hier geht es lediglich darum, ob das Berechnen des 
Scores korrekt funktioniert. \\ 
Da nun alle \texttt{Arrangements} -- also alle Vorbereitungen -- getroffen sind, 
kann der \texttt{Act}-Schritt des Tests vollzogen werden: der Aufruf der 
\texttt{calculateScore}-Methode auf dem \texttt{PlayerService} mit den 
notwendigen Parametern. Da es sich in diesem Fall nicht um das Kriterium 
\texttt{Trainingsbeteiligung} handelt, wird der Score als Durchschnitt aller 
gefilterter Bewertungen berechnet. Ob dieser dem erwarteten Wert entspricht, wird 
abschließend mittels eines geeigneten \texttt{assertThat}-Statements geprüft. \\ 
Für den Fall des Kriteriums \texttt{Trainingsbeteiligung} gibt es darüber hinaus noch 
einen weiteren Testfall, der durch \texttt{test\_07} der
\href{https://github.com/FlorianOhmes/bat_spielzeitenplaner/blob/main/spielzeitenplaner/src/test/java/de/bathesis/spielzeitenplaner/services/PlayerServiceTest.java}{\texttt{PlayerServiceTest.java}}
abgedeckt ist. Auch hier werden wieder sämtliche Abhängigkeiten zu anderen Schichten 
durch gezieltes Mocking aufgelöst, sodass der Code zur Berechnung des 
Trainings-Scores im Fokus steht und in Isolation getestet werden kann, um so eine 
ordnungsgemäße Funktionsweise zu gewährleisten. 

